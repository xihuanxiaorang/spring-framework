# 1、为什么会发生循环依赖？

在代码中，如果bean与bean之间相互去持有对方的引用，此时就会发生循环依赖，如直接依赖，A依赖B，B依赖A；间接依赖，A依赖B，B依赖C，C依赖A；自我依赖，A依赖A。

# 2、Spring是如何解决循环依赖的？

此处的循环依赖指的是基于单例setter注入所形成的循环依赖。Spring主要是基于三级缓存来解决循环依赖问题的，这里的三级缓存其实就是三个Map集合。举个最简单的例子，直接依赖的方式，A依赖B，B依赖A。使用getBean方法获取A实例的时候，会先判断(
一级缓存)或者(二级缓存中是否存在A实例并且是否正在创建)
的引用，此时是不存在的，则会开始创建A实例，将A放入正在创建的集合中，然后会对A进行实例化，实例化A之后，则会把A实例包装成ObjectFactory对象放入到三级缓存中，之后开始给A中的属性赋值，发现需要用到B，给属性赋值的底层还是使用getBean方法获取B实例，所以流程和A很相似，在获取B实例的时候会先判断一级缓存和二级缓存中是存在B实例的引用，此时是不存在的，则会开始创建B实例，将B放入正在创建的集合中，然后对B进行实例化，实例化B之后，则也会把B实例包装成ObjectFactory对象放入到三级缓存中，之后开始给B中的属性赋值，发现需要用到A，上面说了给属性赋值的底层还是使用getBean方法获取A实例，然后此时依旧先判断(
一级缓存)或者(二级缓存中是否存在A实例并且是否正在创建)
的引用，发现二级缓存中不存在但是A已经在创建中了，所以就会从三级缓存中取出A的ObjectFactory，执行getObject方法，实际上就是执行的getEarlyRefrence方法，在这一步可能会执行BeanPostProcessor后置处理器返回代理对象，然后将A从三级缓存中删除，保存到二级缓存，此时返回A的引用，那么B的属性赋值阶段就完成了，B执行完初始化阶段之后，就会将B从正在创建集合中移除，然后将B存放到一级缓存中，同时从三级缓存中删除，此时B的整个创建过程就结束了，将B实例赋值给A中的属性b，此时A的属性赋值阶段也就完成了，那么当A执行完初始化阶段之后，就会将A从正在创建的集合中移除，然后将A存放到一级缓存中，同时从二级缓存中删除，此时A的整个创建过程就结束了，返回A。其实Spring就是使用提前暴露单例bean的引用的方式来解决循环依赖的。

# 3、存在哪几种类型的循环依赖？

结论：Spring可以帮我们解决基于单例setter注入的循环依赖，但是基于构造器参数注入和基于多例setter注入的循环依赖无法解决。

## 3.1、基于构造器参数注入的循环依赖

因为单例bean是在实例化之后，也就是执行了构造方法之后，创建完对象才会有对象的地址，才能提前暴露到三级缓存中，所以此时如果是构造器参数注入形成的循环依赖，不能从缓存中获取到，所以Spring是无法解决构造器参数注入导致的循环依赖。

## 3.2、基于多例setter注入的循环依赖

因为多例作用域的bean并不是在IOC容器启动的时候就开始bean的生命周期的，而是用到的时候调用getBean方法才会开始生命周期流程，从源码中可以看到，每调用一次getBean去获取多例bean，都会先判断bean是否处于正在创建中，如果是的话，则直接抛出异常，否的话就会重新生成一个新的对象，并不会从缓存中去取，所以Spring是无法解决多例bean的循环依赖。

## 3.3、基于单例setter注入的循环依赖

在第2点介绍spring是如何解决循环依赖的就已经详细的回答了，此处不再赘叙。

# 4、只有一级缓存，能不能解决循环依赖？

不能。先得有个概念，一级缓存中存放的是完整的bean对象(也就是已经完成实例化、属性填充、初始化操作的)
，此时假设A依赖B，B依赖A，在给A中的属性赋值的时候发现需要B，这个使用createBean去创建B，然后给B赋值的时候又需要A，这个时候又会使用createBean去创建A，此时就会形成一个死循环，其实也就是没有提前暴露单例bean，所以说只有一级缓存，是不能解决循环依赖的。

# 5、只有一级缓存和三级缓存，能不能解决循环依赖问题？

如果不涉及到AOP代理的话，只有一级缓存和三级缓存是可以解决循环依赖的。但是涉及到AOP代理的时候，就不行了，因为三级缓存中的ObjectFactory每执行一次getObject方法，就会创建一个新的代理对象，所以需要另外一个缓存来存放这个代理对象，所以说只有一级缓存和三级缓存在涉及到AOP时是不能解决循环依赖的。

# 6、为什么需要二级缓存？

如果没有涉及到AOP代理，二级缓存好像显得有点多余。但是如果使用了AOP代理，那么二级缓存就发挥作用了，我们知道bean的AOP动态代理创建是在初始化之后，但是循环依赖的bean如果使用了AOP代理，就无法等到解决完循环依赖后再创建代理对象，因为这个时候已经需要注入属性，所以如果循环依赖的bean使用了AOP，需要提前创建出代理对象返回放入二级缓存中。
前面提到，三级缓存中存放的是ObjectFactroy对象工厂，当执行ObjectFactory#getObject方法的时候，实际上会执行getEarlyReference()
方法获取bean的早期引用，但是我们需要注意的是，每次执行ObjectFactory#getObject方法都会重新产生一个代理对象，这就有问题了，因为我们的bean是单例的，不可能每次都来创建一个新的代理对象，所以，此时就需要二级缓存来保存这个创建出来的代理对象，后面我们从二级缓存中拿，没必要再执行一遍ObjectFactory#getObject方法再产生一个新的代理对象，保证始终只有一个代理对象。

# 7、为什么三级缓存中存放的是ObjectFactory对象工厂，而不是原始的实例对象？

正常情况下，spring中的代理对象是在bean初始化完成之后，执行BeanPostProcessor后置处理器的后置增强方法时创建出代理对象，当我们要注入的对象使用了AOP代理功能时，其他对象在注入这个对象时，注入的应该是对应的代理对象，而不是原始对象，但是spring事先并不知道当前是否存在循环依赖。对于有循环依赖的情况，Spring采用的是实时生成代理对象，也就是等到真正需要注入代理对象的时候才创建。Spring在对象外面包一层ObjectFactory，提前暴露ObjectFactory对象，在被注入时才调用ObjectFactory#getObject方法，实际上执行getEarlyReference()
方法生成代理对象返回，并将生成好的代理对象放入到二级缓存中，真正做到了提前暴露对象而又实时生成代理对象。

# 8、Spring解决循环依赖的三级缓存是否可以减少为二级缓存？

可以。正常情况下，Spring的代理对象是在bean初始化完成之后，执行BeanPostProcessor后置处理器的后置增加方法时创建出代理对象。当我们要注入的对象使用了AOP代理功能时，其他对象在注入这个对象时，注入的应该是这个对象的代理对象，而不是原始对象，但是Spring无法提前知道是否存在循环依赖，所以此时有两种解决方案：

1. 第一种解决方案，不管存不存在循环依赖，在bean实例化之后都提前创建好对应的代理对象，并将代理对象存入到缓存中，出现循环依赖的时候，其他对象就可以直接从缓存中取到代理后的对象，直接注入进去。
1. 第二种解决方案也就是Spring现在使用的方案，不提前创建代理对象，只有出现循环依赖并且被其他对象注入时，才实时生成代理对象，这样在没有循环依赖的情况下，bean就会在初始化完成之后才创建出代理对象。




















